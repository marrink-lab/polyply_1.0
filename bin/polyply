#!/usr/bin/env python3

# Copyright 2020 University of Groningen
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Perform the parsing and input redirect for the
different subcommands. This is the main executable.
"""
import os
import argparse
from pathlib import Path
import polyply
from polyply import (gen_itp, gen_coords, gen_seq, DATA_PATH)
from polyply.src.load_library import load_library

VERSION = 'polyply version {}'.format(polyply.__version__)

def main():
    """
    Parses commandline arguments and call relevant sub_programs.
    """
    parser = argparse.ArgumentParser(
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )

    parser.add_argument('-V', '--version', action='version', version=VERSION)
    ff_group = parser.add_argument_group('Library Files')
    ff_group.add_argument('-list-lib', action='store_true', dest='list_ff',
                          help='List all known force fields, and exit.')
    ff_group.add_argument('-list-blocks', type=str, dest='list_blocks',
                          help='List all Blocks known to the'
                          ' force field selected, and exit.', nargs='*')

    subparsers = parser.add_subparsers()

    # List of Subparsers for the different tools
    parser_gen_itp = subparsers.add_parser('gen_itp')
    parser_gen_coords = subparsers.add_parser('gen_coords')
    parser_gen_seq = subparsers.add_parser('gen_seq')

    #=============================================================================
    # Input Arguments for the itp generation tool
    #=============================================================================

    parser_gen_itp.add_argument('-name', required=True, type=str, dest="name",
                                help="name of the final molecule")

    file_group = parser_gen_itp.add_argument_group('input and output options')
    file_group.add_argument('-lib', dest='lib', required=False, type=str,
                            help='force-fields to include from library', nargs='*')
    file_group.add_argument('-f', dest='inpath', required=False, type=Path,
                            help='Input file (ITP|FF)', nargs="*")
    file_group.add_argument('-o', dest='outpath', type=Path,
                            help='Output ITP (ITP)')
    seq_group = file_group.add_mutually_exclusive_group(required=True)
    seq_group.add_argument('-seq', dest='seq', type=str, nargs='+',
                           help='A linear sequence of residue names.')
    seq_group.add_argument('-seqf', dest='seq_file', type=Path,
                           help='A graph input file (JSON|ITP)')

    parser_gen_itp.set_defaults(func=gen_itp)

    #============================================================================
    #           Input Arguments for the coordinate generation tool
    #============================================================================

    parser_gen_coords.add_argument('-name', required=True, type=str, dest="name",
                                   help="name of the final molecule")

    file_group = parser_gen_coords.add_argument_group('Input and output files')
    file_group.add_argument('-p', dest='toppath', required=False, type=Path,
                            help='topology file (.top)')
    file_group.add_argument('-o', dest='outpath', type=Path,
                            help='output GRO (.gro)')
    file_group.add_argument('-c', dest='coordpath', type=Path,
                            help='input file (.gro)', default=None)

    system_group = parser_gen_coords.add_argument_group('Variables for system generation')
    system_group.add_argument('-dens', dest='density', type=float,
                            help='density of system', default=None)
    system_group.add_argument('-box', dest='box', type=float,
                            help='rectangluar box x y z', default=[], nargs=3)
    system_group.add_argument('-grid', dest='grid_spacing', type=int,
                            help='grid spacing in nm', default=0.2)
    system_group.add_argument('-mi', dest='maxiter', type=int,
                            help='max number of trys to grow a molecule', default=800)
    system_group.add_argument('-res', dest='build_res', type=str,
                            help='list of residues to built', default=[], nargs='+')

    random_walk_group = parser_gen_coords.add_argument_group('Variables for random walk')
    random_walk_group.add_argument('-mir', dest='maxiter_random', type=int,
                            help='max number of trys to place a residue', default=100)
    random_walk_group.add_argument('-sf', dest='step_fudge', type=float,
                            help='scale step length in random walk by fudge factor', default=0.8)
    random_walk_group.add_argument('-mf', dest='max_force', type=float,
                            help='max force to allow in residue placing', default=10**3.0)
    random_walk_group.add_argument('-push', dest='push', type=str,
                            help='one of x,y,z nx, ny, nz', default=[], nargs='+')
    parser_gen_coords.set_defaults(func=gen_coords)

    #============================================================================
    #           Input Arguments for the sequence generation tool
    #============================================================================

    parser_gen_seq.add_argument('-name', required=True, type=str, dest="name",
                                help="name of the final molecule")

    file_group = parser_gen_seq.add_argument_group('Input and output files')
    file_group.add_argument('-f', dest='inpath', required=False, type=Path,
                            help='force-field files (.ff|.itp)', nargs='*')
    file_group.add_argument('-o', dest='outpath', type=Path,
                            help='output file (.json)', required=True)

    macro_group = parser_gen_seq.add_argument_group('Definitions of macros')
    macro_group.add_argument('-from_string', dest='macros', nargs='+', type=str,
                             help=("Define small polymer fragments: "
                                   "the format is <tag>:<#blocks>:<#branches>:<residues> "
                                   "where residues has the format <resname-probability>. "
                                   "Examples are linear PEG of length 10 <A:10:1:PEG-1.0> "
                                   "or a random copolymer of PS-PEG <A:10:1:PS-0.5,PEG-0.5>. "
                                   "But we can also generate branched polymer with 3 generations "
                                   "using <A:3:3:NR3-1.>."), default=[])
    macro_group.add_argument('-from_file', dest='from_file', nargs='+', type=str,
                             help="Use a molecule defined in an input file as fragment. The format "
                                  "is <tag:molecule name>.")

    seq_group = parser_gen_seq.add_argument_group('Definition of sequence')
    seq_group.add_argument('-seq', dest='seq', nargs='+', type=str,
                           help="Define the sequence order in which to combine macros."
                                "The format is <macro_tag, macro_tag, ...>. For example, "
                                "to combine three blocks called A, B, which are defined by the "
                                "macro syntax use <A, B, A> and define how they are connected "
                                "using the connects flag.")
    seq_group.add_argument('-connects', dest='connects', nargs='+', type=str,
                           help="Provide connect records for sequence. "
                                "The format is <seq-index,seq-index-res_id,res_id>. "
                                "For example if we want to connect the first and third "
                                "block in a sequence, using a connection between the second "
                                "and third residue in these blocks respectively the input "
                                "would be <1,3-2,3>.", default=[])
    seq_group.add_argument('-modf_ter', dest='modifications', nargs='+', type=str,
                           help="change the resname of terminii of a specific block "
                                "in the sequence. The format is <SeqID:new_resname>.",
                           default=[])

    parser_gen_seq.set_defaults(func=gen_seq)

    #============================================================================
    # Deal with queries of the polyply library
    #============================================================================

    args = parser.parse_args()

    if args.list_ff:
        libs = os.listdir(DATA_PATH)
        libs = [lib for lib in libs if not lib.startswith("__")]
        print('The following libraries are known:')
        for idx, ff_name in enumerate(libs):
            print('{:3d}. {}'.format(idx, ff_name))
        parser.exit()

    if args.list_blocks:
        force_field = load_library("libs", args.list_blocks, [])
        msg = 'The following Blocks are present in the following libraries: {}:'
        print(msg.format(args.list_blocks))
        for block in force_field.blocks:
            print(block)
        parser.exit()
#    if args.list_links:
#        print('The following Links are known to force field {}:'.format(args.list_links))
#        print(', '.join(known_force_fields[args.list_links]))
#        parser.exit()

    args.func(args)

if __name__ == '__main__':
    main()
